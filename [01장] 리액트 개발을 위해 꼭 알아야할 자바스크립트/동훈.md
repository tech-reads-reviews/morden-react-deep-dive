# 1장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 자바스크립트의 동등 비교

JS의 데이터 타입은 `원시 타입`과 `객체 타입`으로 나뉜다는 것을 우리는 이미 알고 있습니다. 따라서 이번 스터디를 준비하면서 데이터 타입과 관련해 새롭게 알게 된 정보에 대해서 정리해 보았습니다.

### 원시 타입

#### Boolean

Boolean은 true와 false 두 가지 값을 가지지만, 조건문에서는 true와 false로 취급되는 `truthy`와 `falsy` 값이 존재합니다.

| 값              | 타입           |
| --------------- | -------------- |
| false           | Boolean        |
| 0, -0, 0n, 0x0n | Number, BigInt |
| NaN             | Number         |
| '',"",``        | String         |
| null            | null           |
| undefined       | undefined      |

#### Symbol

심벌은 ES6에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌습니다. 심벌 함수를 이용해서만 만들 수 있습니다.

```js
const key = Symbol('key');
const key2 = Symbol('key');

key === key2; // false
```

> 🤔 Symbol을 실제 프로젝트에서는 어떻게 활용할 수 있을까? <br/> 💡 객체의 고유한 키를 만들 때 사용할 수 있습니다.

```js
const id = Symbol('id');
const user = {
  [id]: 1,
  name: 'John',
};
```

### 객체 타입

원시 타입과 비교했을 때, 객체 타입의 가장 큰 특징은 바로 메모리 영역에 값이 아닌 참조를 전달한다는 점입니다.

#### Object.is, 또 다른 비교 방법

`Object.is`메서드를 사용하면 비교가 가능한데, 기존에 사용하던 비교 연산자인 `==`나 `===`와는 다른 조금 다릅니다.

- **`==`와 비교했을 때**, Object.is는 강제 형변환을 하지 않고 비교를 진행합니다. 따라서 타입이 다르다면 false를 얻을 수 있습니다.
- **`===`와 비교했을 때**, Object.is는 NaN과 0/0의 차이를 인식하는 등, 좀 더 개발자가 기대하는 방식으로 비교를 진행합니다.

그러나 여전히 객체 간 비교에 있어서는 JS의 특징으로 인해 ===와 동일하게 동작합니다.

### 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교 역시 `Object.is` 메서드를 기반으로 작동합니다. 다만 이는 ES6에서 추가된 기능이니만큼 폴리필을 함께 사용하며, `shallowEqual`이라는 동등 비교 메서드를 사용합니다. 이때 수행하는 비교는 객체 간 얕은 비교까지만 진행하는데, 그 이유는 리액트에서 사용하는 JSX props가 객체이며 리액트에서는 props에서 꺼내온 값을 기준으로 렌더링을 진행하기에 일차적으로 비교하면 되는 객체이기 때문입니다.

즉, 이러한 JS의 특징을 잘 기억한다면 함수 컴포넌틍에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 렌더링 최적화를 위해 고려해야 할 것들을 쉽게 이해할 수 있을 것입니다.

## 함수

> 📝 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미합니다.

일반적으로 함수를 선언하는 방법은 4가지가 있습니다. 기본적인 **함수 선언문**, **함수 표현식**, **Function 생성자**를 사용하는 방식 그리고 **화살표 함수**입니다. 먼저 함수 선언문과 함수 표현식의 차이에 대해서 알아봅시다.

### 호이스팅(Hoisting): 함수 선언문과 표현식의 차이

`호이스팅`이란, 함수 선언문이 **마치 코드 맨 앞단에 작성된 것처럼 작동**하는 JS의 특징을 의미합니다.

```js
// 함수 선언문
hello(); // hello가 정상적으로 실행됩니다.

function hello() {
  console.log('hello');
}

hello();
```

위 결과를 보면 알 수 있듯, 함수의 호이스팅은 함수에 대한 선언을 실행 전 미리 메모리에 등록하는 작업을 의미합니다. 함수 표현식은 조금 다릅니다.

```js
// 함수 표현식
hello(); // 오류 발생

var hello = function () {
  console.log('hello');
};
```

위 함수는 호출하면 오류가 발생합니다. 그 이유는 변수는(var) 런타임 이전에 undefined로 초기화되고, 런타임에 함수가 할당되어 작동하기 때문입니다. 둘 중 정답은 없습니다. 적절한 상황에 적절한 방법을 사용합시다.

### 화살표 함수

`화살표 함수`는 ES6부터 새롭게 추가된 함수 생성 방식입니다.

```js
const hello = () => console.log('hello');
```

기존의 함수 선언문과는 다음과 같은 차이가 있습니다.

- constructor를 사용할 수 없다.
- arguments가 존재하지 않는다.
- 함수 자체의 바인딩을 갖지 않기 때문에, 화살표 함수에서 this를 참조하면 상위 스코프의 this를 그대로 따른다.

따라서 this를 사용해야 하는 경우, 화살표 함수를 무분별하게 사용하지 않도록 합시다.

이 외에도 다양한 함수들이 있습니다.

### 즉시 실행 함수(IIFE)

`즉시 실행 함수`는 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미합니다.

```js
(function (a, b) {
  return a + b;
})(10, 24);
```

이런 IIFE는 한 번만 호출되고, 다시 호출할 수 없는 함수이기 때문에 **독립적인 함수 스코프**를 운용할 수 있으며, **리팩터링에 도움이 된다**는 장점이 있습니다.

### 고차 함수

JS의 함수는 일급 객체이기 때문에 함수를 인수로 받거나 결과로 새로운 함수를 반환할 수 있습니다. 이런 역할을 하는 함수를 `고차 함수`라고 합니다.

```js
const doubledArray = [1, 2, 3].map((item) => item * 2);
```

`map()`의 경우 함수를 매개변수로 받기에 대표적인 고차 함수라고 할 수 있습니다. 비슷하게 리액트에서는 함수 컴포넌트를 인자로 받아 새로운 함수 컴포넌트를 반환하는 고차 컴포넌트를 만들 수 있습니다. 그렇다면 이러한 함수를 잘 활용하려면 어떻게 해야 할까요?

### 함수를 만들 때 주의해야 할 사항

#### 함수의 부수효과를 최대한 억제하라

리액트의 관점에서 본다면 불필요한 useEffect를 최소화 하는 것이 그 일환이라고 볼 수 있습니다.

#### 가능한 한 함수를 작게 만들어라

하나의 함수는 하나의 일만 잘 하도록 만듭시다. 만약 함수의 코드가 길어진다면, 세부 역할을 분리해 보도록 합시다.

#### 누구나 이해할 수 있는 이름을 붙여라

- 함수의 이름을 간결하고 이해하기 쉽게 붙이는 것이 좋습니다. 한글 이름을 사용해도 좋습니다! 이와 관련해서는 토스의 [세종대왕 프로젝트](https://tosspayments-dev.oopy.io/chapters/frontend/posts/hangul-coding-convention)를 참고해 주세요.
- 또한 `useEffect`나 `useCallback`등의 훅에 넘겨주는 콜백 함수의 이름을 지정하는 것도 가독성에 도움이 됩니다.

## 클래스

저는 리액트를 16.8 버전 이후부터 접했기 때문에, 클래스로 작성된 컴포넌트를 사용할 일이 없었습니다. 앞으로도 없을 것 같지만, 그래도 클래스에 대해서 배워둔다면 후에 레거시 코드를 읽거나 하는 등의 상황에서 도움이 될 수 있다고 생각합니다.

> 📝 클래스란 일종의 템플릿으로, 특정 객체를 반복적으로 만들기 위해서 사용합니다.

### 생성자(Constructor)

생성자는 객체를 생성하는 특수한 메서드로, 각 클래스 내부에는 하나만 존재할 수 있습니다. 생성자에서 달리 수행할 작업이 없다면 생략해도 됩니다.

```js
class Car {
  constructor(name) {
    this.name = name;
  }
}
```

### getter와 setter

`getter`는 클래스에서 값을 가져올 때, `setter`는 클래스 필드에 값을 할당할 때 사용합니다.

```js
class Car {
  constructor(name) {
    this.name = name;
  }

  get Age() {
    return this.age;
  }

  // car_instance.age = 32

  set Age(value) {
    this.carAge = value;
  }

  // car_instance.age 로 접근 가능
}
```

### 인스턴스 메서드

`인스턴스 메서드(프로토타입 메서드)`란 클래스 내부에서 선언된 메서드를 의미합니다. 새로 생성된 객체에서 클래스에 선언한 메서드에 접근할 수 있는 이유가 바로 prototype에 할당되었기 때문입니다.

### 정적 메서드

정적 메서드란 클래스의 인스턴스가 아닌 클래스의 이름으로 호출할 수 있는 메서드를 의미합니다.

```js
const myCar = new Car();

Car.hello(); // 정적 메서드를 호출하는 방법
```

이때 정적 메서드 내부의 this는 클래스 자신을 가리키기 때문에 일반적인 this를 사용할 수 없습니다. 그렇지만 인스턴스를 생성하지 않아도 접근할 수 있다는 점에서 유틸 함수로 많이 사용하는 편입니다.

### 상속

상속(extends)는 기존 클래스를 상속받은 자식 클래스에서 상속받은 클래스를 기반으로 확장하는 것이라고 볼 수 있습니다.

```js
class Car {
  // 클래스 관련 코드 작성...
}

class Truck extends Car {
  // 클래스 관련 코드 작성...
}
```

## 클로저

> 📝 클로저란, 함수와 함수가 선언된 어휘적 환경의 조합입니다 _- MDN_

```js
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }
}
```

예를 들어, `innerAdd` 함수에서는 `a`가 선언되지 않았는데 어떻게 a의 값을 알 수 있을까요? 그 이유는 `innerAdd`와 `a` 모두 `add` 함수 내부에서 선언되어 있기 때문입니다. 어휘적 환경이란 이를 뜻합니다.

### 변수의 유효 범위, 스코프

JS의 스코프는 세 가지입니다

- **전역 스코프**: 전역 스코프에 선언된 변수는 어디서든 접근 가능합니다.
- **함수 스코프**: 기본적으로 JS는 함수 레벨 스코프를 가집니다. 함수 내에서 선언된 변수는 해당 함수 내에서만 접근 가능합니다.
- **블럭 스코프**: `let`과 `const`로 선언된 변수는 블록 스코프를 가집니다. `{}`로 둘러싸인 영역 내에서만 접근 가능합니다.

또한 JS에서 스포크는 일단 가장 가까운 스코프에 변수가 존재하는지 확인한다는 것을 명심합시다.

### 리액트에서의 클로저

그렇다면 리액트의 함수 컴포넌트 훅에서 클로저는 어떻게 사용될까요? `useState`가 이러한 클로저의 원리를 잘 보여주는 예시입니다.

```js
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    setState((prev) => prev + 1);
  }
}
```

클로저를 활용했기 때문에, setState는 prev를 계속 알고 있습니다.

## 이벤트 루프와 비동기 통신의 이해

이번 회차에서 가장 흥미로웠던 부분이었습니다. JS는 싱글 스레드에서 작동합니다. 즉, 한 번에 하나의 작업만 동기 방식으로 작동한다는 뜻입니다. 그런데 저희는 이미 웹에서 많은 작업들을 비동기적으로 처리하고 있습니다. 이를 도와주는 것이 바로 `이벤트 루프(Event Loop)`입니다.

### 호출 스택과 이벤트 루프

> 📝 이벤트 루프란 JS 런타임 외부에서 비동기 작업의 실행을 돕기 위해 만들어진 장치라고 생각해도 무방합니다.

호출 스택(Call Stack)이란 수행해야 할 함수나 코드를 순차적으로 담아두는 스택입니다. 그리고 이 호출 스택이 비어있는지 여부를 판단하는 것이 바로 이벤트 루프입니다.

```js
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('foo');
  setTimeout(bar(), 0);
  baz();
}
```

위 코드의 실행 결과는 foo, baz, bar입니다. `setTimeout`이 저희가 예상한대로 작동하지 않은 이유는, 그것이 태스크 큐에 저장되어 있기 때문입니다.

### 태스크 큐와 마이크로 태스크 큐

> 📝 태스크 큐란 실행해야 할 태스크의 집합을 의미합니다.

이름과는 다르게 set의 형태를 띄고 있는데, 그 이유눈 태스크 큐는 **가장 오래된 실행 가능한 태스크**를 가져와야 하기 때문입니다. 여기서 이야기하는 실행 가능한 태스크란 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미합니다. 이러한 비동기 함수는 메인 스레드가 아닌 태스크 큐가 할당하는 별도의 스레드에서 수행되며, 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것이 바로 브라우저나 Node.js의 역할입니다.

이와는 다르게 `마이크로 태스크 큐`라는 것도 있습니다. 이벤트 루프는 하나의 마이크로 태스크 큐를 가지고 있는데, 여기에는 일반적으로 태스크 큐에 들어가는 태스크와는 또 다른 태스크가 들어갑니다. 이 마이크로 태스크 큐는 태스크 큐보다 우선권을 갖습니다.

- 태스크 큐: setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐: process.nextTick, Promises, queueMicroTask, MutationObserver

이벤트 루프는 항상 호출 스택을 확인하며, 호출 스택이 비어있다면 마이크로 태스크 큐의 작업을 호출 스택으로 올려 수행합니다. 마이크로 태스크 큐의 작업이 모두 종료되면, 태스크 큐에 있던 작업을 콜스택이 비어 있는지 확인한 후 호출 스택으로 올리게 됩니다. 그리고 **렌더링은 마이크로 태스크 큐가 실행되고 나서** 일어나게 됩니다.

이렇게 이론적인 내용은 글만 봐서는 이해하기 어렵습니다. [이벤트 루프를 시각화한 영상](https://www.youtube.com/watch?v=eiC58R16hb8&t=37s)을 통해서 보다 쉽게 이해할 수 있습니다.

## 리액트에서 자주 사용하는 자바스크립트 문법

> 📝 리액트에서 자주 사용하는 JS 문법을 익혀두면 리액트가 어떻게 작동하는지 이해하기 쉽습니다.

### 구조 분해 할당

객체의 값 혹은 배열의 값을 분해해 개별 변수에 할당하는 방법입니다.

```js
// 배열 구조 분해 할당
const array = [1, 2, 3, 4, 5];

const [first, second, third, ...arrayRest] = array;

// 객체 구조 분해 할당
const person = { name: 'John', age: 30, job: 'developer' };
const { name, age } = person;
console.log(name); // 'John'
console.log(age); // 30
```

별 차이는 없어 보이지만, 객체 구조 분해 할당을 트랜스파일 할 경우에는 이야기가 조금 달라집니다. 객체 구조 분해 할당은 트랜스파일 시 코드가 더 복잡하고 길어지는데, 이로 인해 **번들링 크기가 커지게 됩니다**. 따라서 만약 자신의 웹 애플리케이션이 ES5 환경을 고려해야 하고, 또 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 사용해야 하는지 검토할 필요가 있습니다. 혹은 `lodash.omit`이나 `rambda.omit`과 같은 외부 라이브러리를 사용하는 것도 좋은 방법입니다.

### 전개 구문

`전개 구문(Spread Syntax)`은 배열, 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간편하게 사용할 수 있는 구문입니다.

```js
// 배열의 전개 구문
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];
console.log(copiedArray); // [1, 2, 3]

// 객체의 전개 구문
const originalObj = { x: 1, y: 2 };
const copiedObj = { ...originalObj };
console.log(copiedObj); // { x: 1, y: 2 }
```

이러한 전개 구문을 활용하면 기존의 배열 혹은 객체에 영향을 미치지 않고 새로운 배열 및 객체를 생성할 수 있다는 장점이 있습니다. 하지만 구조 분해 할당과 마찬가지로, 객체의 경우 트랜스파일 시 번들링 크기가 커지기 때문에 이를 고려해서 사용해야 합니다.

### Array 프로토타입의 메서드: map, filter, reduce, forEach

위 메서드들은 기존 배열을 변경하지 않고 새로운 배열을 반환합니다. 또한 ES5부터 등장했기 때문에 추가적인 폴리필이 필요하지 않다는 장점도 가지고 있습니다. 기본적인 메서드의 활용법에 대해서는 알고 있으니, `forEach`메서드와 관련해서 새롭게 알게 된 사실에 대해서 다뤄보고자 합니다.

```js
function run() {
  const arr = [1, 2, 3];
  arr.forEach((item) => {
    console.log(item);
    if (item === 1) {
      console.log('finished!');
      return;
    }
  });
}

run();
```

중간에 return이 있어서 1이 출력된 뒤 finished가 출력되며 실행이 종료될 줄 알았지만, 그렇지 않습니다. 그 이유는 return이 함수의 return이 아닌 콜백 함수의 return으로 간주되기 때문입니다.

> 🚨 forEach는 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출 수 없습니다.

### 삼항 조건 연산자

JSX에서는 삼항 조건 연산자를 조건부 렌더링이 필요할 때 사용합니다. 다만 중첩해서 사용하면 가독성이 떨어지기 때문에 이는 지양하는 것이 좋습니다. 삼항 연산자 말고도 IIFE를 사용해 조건부 렌더링을 진행하는 방법도 있지만, 가독성을 해치고 불필요한 함수를 선언해야 하기 때문에 선호되지는 않습니다.

## 선택이 아닌 필수, 타입스크립트

> 📝 TypeScript는 기존의 JavaScript에 타입을 추가한 슈퍼셋(Superset)입니다.

JS는 런타임에서 타입을 할당하는 동적 타입 언어입니다. 이로 인해 코드를 실행하지 않으면 타입과 관련해서 발생하는 문제를 확인할 수 없다는 단점이 있었습니다. JSDoc 혹은 타입 연산자를 활용해 이러한 문제를 해결하려고 했으나 매번 이런 방식을 사용해 코드를 작성하기에는 번거롭다는 문제가 있었습니다.

TS는 이러한 문제를 해결할 수 있는 정적 타입 언어입니다. 타입 체크를 런타임이 아닌 빌드(트랜스파일) 과정에서 할 수 있도록 도와주기 때문에 많은 사랑을 받고 있습니다.
