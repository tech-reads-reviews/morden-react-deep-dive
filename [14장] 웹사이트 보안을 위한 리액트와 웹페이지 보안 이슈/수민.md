# 웹사이트 보안

## 리액트에서 발생하는 크로스 사이트 스크립팅 (XSS)

<aside>
💡

XSS란?

공격자가 악성 스크립트를 웹 페이지에 삽입해 사용자의 브라우저에서 실행되도록 만드는 공격입니다.

</aside>

### **XSS의 종류**

1. **반사형(Reflected XSS)**
   - 공격자가 조작한 URL을 클릭할 때, 사용자에게 악성 스크립트가 실행됨.
   - 주로 피싱 공격에 사용됨.
2. **저장형(Stored XSS)**
   - 공격자가 악성 스크립트를 웹사이트에 **저장**시키고, 그 페이지를 보는 모든 사용자가 피해를 입음.**예:** 게시판, 댓글, 프로필 정보에 악성 코드를 저장하는 경우.
3. **DOM 기반 XSS**
   - 서버가 아닌 **클라이언트 측 자바스크립트 코드**에서 발생.
   - 페이지 로딩 후 자바스크립트가 DOM을 변경할 때 공격 코드가 실행됨.**예:** `innerHTML`로 사용자 입력을 직접 삽입할 때.
   -

### **XSS의 위험성**

- **세션 탈취**: 쿠키를 빼내 세션을 도용할 수 있음.
- **피싱**: 가짜 로그인 페이지를 띄워 사용자 정보를 수집.
- **키로깅(Keylogging)**: 입력된 데이터를 추적해 비밀번호를 알아낼 수 있음.
- **웹사이트 변조**: 사용자가 보는 웹 페이지 내용을 조작.

일반적으로 xss공격은 DOM기반의 XSS공격이 주된 방법입니다.

리액트는 HTML 및 DOM에 데이터를 렌더링할 때 **자동으로 escaping**(이스케이프 처리)을 수행합니다.

사용자 입력에서 `<`, `>`, `"`, `'` 같은**특수 문자**를 자동으로 HTML 엔티티로 변환합니다.

```
<script>alert(1)</script>
```

```
&lt;script&gt;alert(1)&lt;/script&gt;
```

이 덕분에 악성 스크립트가 브라우저에서 실행되지 않습니다.

하지만 이 것이 모든 XSS공격으로부터 안전하다는 의미일까요? ❌

실제 HTML요소를 JSX내부에서 직접 DOM에 렌더링해야하는 상황이면 어김없이 XSS취약포인트에 직면하게 됩니다.

ex)

- `dangerouslySetInnerHTML` 사용

리액트에서 DOM 요소에 **HTML을 직접 삽입**할 때 사용하는 메서드입니다.

- `useRef`**를 활용한 직접 삽입**

`useRef`를 사용하여 직접 DOM에 접근하여 HTML을 삽입할 수 있다. 이 때도 사용자가 입력한 데이터를 그대로 출력하기 때문에 XSS 공격에 취약하다.

### **리액트에서 XSS 문제를 피하는 방법**

1.  HTML을 안전한 코드로 치환하는 방법인 sanitize | escape라는 과정을 거쳐야 한다.

- DOMpurity
- sanitize-html
- js-xss

1. innerHTML대신 innerText사용합니다

<aside>
💡

innerHTML 은 요소(element) 내에 포함된 HTML 마크업을 가져오거나 설정합니다.
innerText 속성은 요소의 **렌더링된** 텍스트 콘텐츠를 나타냅니다. (**렌더링된**에 주목하세요. \*\*\*\*innerText는 "사람이 읽을 수 있는" 요소만 처리합니다.)

textContent 속성은 노드의 텍스트 콘텐츠를 표현합니다.

</aside>

1. 세션을 쿠키로 관리할 때 쿠키를 **HTTP-Only** 속성으로 설정해 **JavaScript에서 접근할 수 없도록** 해야 합니다.

## **getServerSideProps와 서버 컴포넌트를 주의하자**

`getServerSideProps` 가 반환하는 props 값은 모두 사용자의 HTML에 기록되고, 전역 변수로 등록되어 스크립트로 충분히 접근할 수 있는 보안 위협에 노출되는 값이 된다.

`getServerSideProps`가 반환하는 값 또는 서버 컴포넌트가 클라이언트 컴포넌트 반환하는 props는 반드시 필요한 값으로만 철저하게 제한되어야 한다.

## **<a> 태그의 값에 적절한 제한을 둬야 한다**

해당 코드를 보자

```jsx
<a href=”javascript:” onclick={handle}>
```

url이동을 막고 onclick 이벤트 실행만을 위한 a 태그 이다

이런방식은 마크업 관점으로 봤을때 안티패턴으로 볼수있다.

href가 실행되지않은것이 아니라 javascript: 가 실행된것이다.

href에 악의적인 스크립트를 삽입할수있다면 보안 이슈로 이어지기때문에

이러한 경우에는 button을 사용하는것이 바람직하다.

## **HTTP 보안 헤더 간단하게 알아보기**

1.  브라우저가 어떤 리소스(스크립트, 이미지 등)를 로드할 수 있는지 제한
    **Content-Security-Policy (CSP)**
2.  브라우저가 HTTP 대신 항상 HTTPS를 사용하도록 강제한다
    **Strict-Transport-Security**
3.  이 헤더는 브라우저가 MIME 타입을 **변경하지 못하도록** 한다
    **X-Content-Type-Options**
4.  사이트가 다른 웹사이트에 **iframe**으로 삽입되는 것을 막습니다.
    **X-Frame-Options**
5.  웹 페이지에서 특정 기능(카메라, 위치, 마이크 등)을 사용할 수 있는지 제한
    **Permissions-Policy**
