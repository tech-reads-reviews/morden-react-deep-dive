# 서버 컴포넌트≠서버 사이드 렌더링

# app 디렉토리

### 레이아웃의 변화

기존의 방식

⇒react-router-dom 을 사용해 <Routes> 의 외부영역을 공통으로 꾸미는 작업

독립된 페이지에 공통으로 넣으려면 \_document, \_app 이 유일

app디렉토리 도입 이후

⇒app레이아웃 등장으로 레이아웃을 유연하게 구성할수 있게 되었다

### **라우팅**

pages⇒ app 디렉터리

폴더명까지만 주소로 변환

- layout.js
- page.js (params,searchParams)
- error.js
- not-found.js
- loading.js(Suspense기반)
- route.js (request,context)

# 서버 사이드 렌더링

클라이언트 애플리케이션의 자바스크립트 파일을 서버에서 먼저 HTML로 렌더링 합니다.

페이지가 정상적으로 동작하기 위해서는 자바스크립트 번들이 모두 다운로드되고 하이드레이션이 완료되어야 하지만 빈 화면 대신 데이터가 존재하는 HTML을 제공함으로써 무거운 자바스크립트 파일이 다운로드되는 동안 사용자에게 의미 있는 콘텐츠를 제공할 수 있습니다.

목적:

non-interactive한 버전의 클라이언트 컴포넌트를 최대한 빠르게 브라우저에 전달

초기 페이지의 First Contentful Paint 또는 Largest Contentful Paint 속도를 향상

단점:

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청에 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

# 서버 컴포넌트

하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법

목적 :

서버 컴포넌트는 클라이언트에 자바스크립트를 전달하지 않기 때문에 클라이언트에서 불필요한 자바스크립트 번들을 줄일 수 있음.

### 차이점

- 서버 컴포넌트의 코드는 클라이언트로 전달되지 않습니다. 하지만 서버 사이드 렌더링의 모든 컴포넌트의 코드는 자바스크립트 번들에 포함되어 클라이언트로 전송됩니다.
- 서버 컴포넌트는 페이지 레벨에 상관없이 모든 컴포넌트에서 서버에 접근 가능합니다. 하지만 Next.js의 경우 가장 top level의 페이지에서만 `getServerProps()`나 `getInitialProps()`로 서버에 접근 가능합니다.

> 리액트 서버 컴포넌트는 서버 사이드 렌더링의 대체재가 아닙니다. 하지만 사용자 경험 향상을 위해 함께 사용할 수는 있습니다

### 서버 사이드 렌더링으로 초기 HTML 페이지를 빠르게 보여주고, 서버 컴포넌트로는 클라이언트로 전송되는 자바스크립트 번들 사이즈를 감소시킨다

# fetch의 발달

getStaticProps== X

정적 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해서 재사용할 수 있게끔 해두었다.

동적 라우팅에 대해서는 서버에 매번 요청이 올 때 마다 컴포넌트를 렌더링하도록 변경했다.

**revalidating**

fetch의 기본 작동을 재정의해 해당 데이터의 유효한 시간(revalidate값)을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능하다.

# 서버액션

API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행

‘use server’ 선언하고 함수는 async로 호출

### form action에 달아주는 함수를 서버 액션으로 만들어주게 되면 해당 이벤트를 발생시키는 것은 클라이언트지만 실제로 함수 자체가 수행되는 것은 서버가 된다.

⇒ CORS이슈를 발생시키지 않을수 있다???

이벤트 발생은 클라이언트지만 실제 함수자체가 수행되는곳은 서버가된다.

주의 할 점

서버액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.

클라이언트 컴포넌트에서 서버액션을 쓰고싶다면 ‘use server’로 서버액션만 모여있는 파일을 별도로 import 해야한다.
