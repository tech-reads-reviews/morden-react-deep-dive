# 2장: 리액트 핵심 요소 깊게 살펴보기

## 1. JSX란?

> 📝 JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법입니다.

- JSX는 리액트의 전유물이 아닌 내장형 구문이다.
- ECMAScript의 일부는 아니기 때문에, 반드시 트랜스파일러를 거쳐야 한다.

### 1.1 JSX의 정의

> JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성되어 있다.

#### JSX Element

JSX의 기본 요소로, HTML의 요소와 비슷한 역할을 한다. JSX Element가 되기 위해서는 다음과 같은 형태여야 한다.

- `JSXOpeningElement`: 일반적으로 볼 수 있는 요소
- `JSXClosingElement`: Opening Element가 종료되었음을 알리는 요소
- `JSXSelfClosingElement`: 스스로 닫히는 형태
- `JSXFragment`: 아무런 요소가 없는 형태

```jsx
// Opening Element
<JSXElement JSXAttributes(optional)>

// Closing Element
</JSXElement>

// JSXSelfClosingElement
<JSXElement JSXAttributes(optional) />

// JSXFragment
<>JSXChildren(optional)</>
```

> 🤔 JSX 요소명은 왜 대문자로 시작해야 하나요? <br/>🧑🏻‍💻 그 이유는 HTML 요소와 JSX에서 사용자가 만든 컴포넌트 이름을 구분짓기 위해서입니다.

#### JSXElementName

JSXElement의 요소 이름으로 사용할 수 있는 것을 의미한다.

- `JSXIdentifier`: JSX 내부에서 사용할 수 있는 식별자로, JS의 식별자 규칙과 동일하다.
- `JSXNamespacedName`: `:`을 통해 서로 다른 식별자를 이어줄 수 있으나, 두 개 이상을 이을 수는 없다.
- `JSXMemberExpression`: `.`을 통해 서로 다른 식별자를 이어줄 수 있다. `JSXNamespacedName`와는 다르게, 여러 개를 이을 수 있다.

```jsx
function JSXIdentifier() {
  return <$></$>;
}

function JSXNamespacedName() {
  return <foo:bar></foo:bar>;
}

function JSXMemberExpression() {
  return <foo.bar></foo.bar>;
}
```

#### JSXAttributes

`JSXElement`에 부여할 수 있는 속성이다. 단순한 속성이기 때문에 필수가 아니다.

- `JSXSpreadAttributes`: JS의 전개 연산자와 동일한 역할
- `JSXAttribute`: 속성을 나타내는 키-값 쌍으로 이루어져 있다.
  - `JSXAttributeName`: 속성의 키 값으로, JSXIdentifier와 JSXNamespacedName이 가능하다.
  - `JSXAttributeValue`: 속성의 키에 할당할 수 있는 값이다.
    - 큰따옴표/작은따옴표로 구성된 문자열
    - {AssignmentExpression}
    - JSXElement

#### JSXChildren

`JSXElement`의 자식 값을 나타낸다.

- JSXChild: JSXChildren을 이루는 기본 단위로 0개 이상 존재할 수 있다.
  - `JSXText`: `{`,`<`,`>`,`}`을 제외한 문자열이다. 이는 다른 JSX 문법과 혼동을 줄 수 있기 떄문이다.
  - `JSXElement`: 다른 JSX 요소가 값으로 들어갈 수 있다.
  - `JSXFragment`: 빈 요소 역시 들어갈 수 있다.
  - `{JSXChildExpression(optional)}`: JS의 AssignmentExpression을 의미한다.

```jsx
// JSXText
function JSXText() {
  return <>{'{} <>'}</>;
}

// JSXChildExpression
export default function App() {
  return <>{(() => 'foo')()}</>;
}
```

#### JSXStrings

`JSXAttributeValue`와 `JSXText`는 HTML과 JSX 사이에 복사/붙여넣기를 쉽게 할 수 있도록 설계되어 있다. 즉 HTML에서 사용 가능한 문자열은 JSXStrings에서도 가능하다.

> 단, `\`로 시작되는 이스케이프 문자 형태소는 JS와는 다르게 아무런 제약 없이 사용할 수 있다.

### 1.2 JSX 예제

위 내용을 바탕으로 간단한 JSX를 만들어 볼 수 있는 절이었다. 그동안 리액트를 사용하면서 자주 볼 수 있는 형태라 눈에 금방 익었다.

### 1.3 JSX는 어떻게 자바스크립트에서 변환될까?

> 📝 JSX가 JS로 변환될 때에는 `@babel/plugin-transform-react-jsx` 플러그인을 사용한다.

```jsx
const Component = (
  <div required={true}>
    <span>hello world</span>
  </div>
);
```

예를 들어, 위 JSX를 변환한 결과는 다음과 같다.

```js
'use strict';

var Component = React.CreateElement(
  'div',
  { required: true },
  React.CreateElement('span', null, 'hello world')
);

// automatic runtime 트랜스파일 결과
var _jsxRuntime = require('custom-jsx-library/jsx-runtime');

var Component = (0, _jsxRuntime.jsx)('div', {
  required: true,
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'hello world',
  }),
});
```

약간의 차이는 있지만, 공통점은 먼저 **JSXElement를 첫 번째 인수로 선언**해 요소를 정의하고, 나머지 옵셔널은 이후 인수로 넘겨주어 처리한다는 것이다. 이 점을 활용한다면, JSXElement를 렌더링할 때 굳이 요소 전체를 감싸지 않더라도 처리할 수 있다. JSXElement만 다르고, 옵셔널이 동일한 상황에서 유용하게 쓰일 수 있다.

```tsx
// 기존에 두 요소를 따로 작성해야 하는 번거로움이 사라졌다.
import { createElement } from 'react';

function DivOrSpan({
  isDiv,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(isDiv ? 'div' : 'span', { className: 'item' }, children);
}
```

### 1.4 정리 및 느낀점

이번 절에서는 JSX가 무엇인지와 그것의 구조에 대해서 살펴보았다. 그동안 리액트로 개발을 진행하면서 JSX의 구조를 생각해 본 적은 없었는데, 이번 절에서 잘 알게 되었다. 또한 JSX가 자바스크립트에서 변환되는 과정이 인상깊었다. 특히 `createElement`를 사용해 JSX를 작성하는 방법을 알게 되었으니, 추후 이를 프로젝트에 적용시킬 때 중복 코드를 최소화 할 수 있을 것이다.

## 2. 가상 DOM과 리액트 파이버

리액트의 특징으로 가장 많이 언급되는 것, 바로 `가상 DOM(Virtual DOM)`이다. 이번 절에서는 이 가상 DOM에 대해서 알아봤다.

### 2.1 DOM과 브라우저 렌더링 과정

> 📝 DOM(Document Object Model)은 웹페이지에 대한 인터페이스이다.

DOM은 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 렌더링해야 보여줄지에 대한 정보를 담고 있다. 그렇다면 브라우저는 웹사이트에 대한 정보 요청을 받았을 때 화면을 그리기까지 어떤 과정을 거칠까?

1. 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM을 만든다.
3. 이 과정에서 CSS 파일을 만난다면 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 CSS를 파싱해 CSSOM을 만든다.
5. 브라우저는 2에서 만든 노드를 순회하는데, 사용자 화면에 보이는 노드만 방문한다.
6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 스타일 정보를 DOM에 적용한다.
   - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 나타나야 하는지를 계산한다.
   - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그린다.

![browser render tree from https://web.dev/articles/critical-rendering-path/render-tree-construction](https://web.dev/static/articles/critical-rendering-path/render-tree-construction/image/dom-cssom-are-combined-8de5805b2061e_856.png) 이 과정을 모식화하면 위와 같다.

![browser rendering performance in chrome dev tool from https://web.dev/articles/critical-rendering-path/render-tree-construction](https://web.dev/static/articles/critical-rendering-path/render-tree-construction/image/measuring-layout-devtool-b69472538e803_856.png) 개발자 도구에서도 위와 같이 HTML 파싱, 레이아웃, 페인팅 과정이 일어나는 것을 확인할 수 있다.

### 2.2 가상 DOM의 탄생 배경

> 📝 가상 DOM은 리액트가 관리하는 가상의 DOM으로, DOM 계산을 브라우저가 아닌 메모리에서 진행하기 때문에 렌더링 과정을 최소화할 수 있다.

앞서 살펴본 것처럼 브라우저가 웹페이지를 렌더링 하는 것은 많은 비용이 든다. 물론 특정한 요소의 색상이 변경되는 것과 같은 단순한 경우는 페인팅 작업만 일어나게 된다. 그러나 다음과 같은 경우를 생각해보자.

- 특정 요소의 위치와 크기가 변경될 경우: 레이아웃 ➡ 리페인팅이라는 필연적인 작업이 발생한다.
- DOM 변경이 일어나는 요소가 많은 자식 요소를 가진 경우: 하위 자식 요소도 함께 변경돼야 한다.

이러한 렌더링 이후 추가 렌더링 작업의 경우 SPA에서 더욱 많아지는 경향이 있다. 일반적인 웹페이지라면 페이지가 변경될 때 새로운 HTML을 받아서 처음부터 렌더링을 진행하지만, SPA의 경우 **하나의 페이지에서 변경되는 요소를 계속해서 계산**해야 한다.

따라서 인터렉션에 따른 DOM의 최종 결과물을 간편하게 제공하는 것이 개발자와 브라우저 모두에게 유용할 것이다.

이러한 문제점을 해결하기 위해 탄생한 것이 바로 `가상 DOM(Virtual DOM)`이다. 가상 DOM은 웹페이지가 표시해야 할 DOM을 메모리에 저장해 두었다가 리액트가 실제 변경에 대한 준비가 완료됐을 때 브라우저의 DOM에 반영하게 된다. 이 과정에서 기존의 브라우저에서 여러 번 발생했을 렌더링 과정을 최소화할 수 있기 때문에 브라우저와 개발자의 부담을 덜 수 있다.

주의해야 할 점은, 익히 알려진것과는 달리 리액트의 가상 DOM이 DOM보다 무조건적으로 빠르지는 않다는 것이다. 다만, 앱을 개발할 수 있을 만큼 합리적으로 빠르기 때문에 채용했다고 보는 것이 옳다고 한다.

### 2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

> 📝 리액트는 평범한 자바스크립트 객체인 리액트 파이버를 사용해 가상 DOM을 관리한다.

`리액트 파이버(React fiber)`는 가상 DOM과 렌더링 최적화를 위해서 리액트에서 사용하는 자바스크립트 객체이다. 이는 `파이버 재조정자(fiber reconciler)`가 관리하며, 가상 DOM과 실제 DOM 사이에 차이가 존재한다면 `재조정(reconciliation)` 작업을 통해 이를 업데이트한다.

리액트 웹 애플리케이션에서 발생하는 반응성 문제를 해결하기 위해, 리액트 파이버는 다음과 같은 일을 할 수 있다.

- 작업을 작은 단위로 분할하고 쪼개서 우선순위를 매기기.
- 해당 작업을 일시 중지하고 나중에 시작하기.
- 이전 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기하기.

이러한 과정은 모두 비동기로 일어나게 되는데, 이는 기존에 동기적이었던 렌더링 스택의 문제를 해결하기 위해 도입되었다.

리액트 파이버는 하나의 작업 단위로 구성되어 있으며, 리액트는 이러한 작업 단위를 하나씩 처리하고 `finishedWork()`라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 DOM에 변경 사항을 반영한다.

1. 렌더 단계: 사용자에게 노출되지 않는 모든 비동기 작업들을 수행함
2. 커밋 단게: DOM에 실제 변경 사항을 반영하기 위한 작업인 `commitWork()`를 수행함 (동기적이며, 중단할 수도 없음)

실제 코드에서 리액트 파이버는 다음과 같이 구성되어 있다.

```js
function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;
  this.refCleanup = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  // 그 외 코드...
}
```

파이버는 이렇게 단순한 자바스크립트 객체로 구성되어 있으며, 리액트 요소와는 달리 파이버는 컴포넌트가 마운트 되는 시점에 생성되면 가급적이면 재사용된다는 점이다. 파이버가 가지는 주요 속성들은 다음과 같다:

- `tag`: element 하나당 생성되는 파이버를 식별하기 위함.
- `stateNode`: 파이버 자체에 대한 참조 정보.
- `child, sibling, return`: 파이버 간의 관계를 나타냄.
- `index`: 파이버의 여러 형제들 사이에서 자신의 위치를 식별하기 위함
- `pendingProps`: 아직 작업을 처리하지 못한 props
- `memoizedProps`: pendingProps를 기준으로 렌더링이 완료된 이후 pendingProps를 저장해 관리
- `updateQueue`: 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐
- `memoizedState`: 함수 컴포넌트의 훅 목록
- `alternate`: 리액트 파이버 트리의 반대편 트리

이렇게 생성된 파이버는 state가 변경되거나 혹은 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점에서 실행된다. 또한 우선순위에 따라 작업을 유연하게 처리하기도 한다.

이런 파이버를 기반으로 생성된 파이버 트리는 총 두개가 있다. 현재의 모습을 담은 것과 작업 중인 상태를 나타내는 `workInProgress` 트리 두 개이다. 리액트 파이버의 작업이 끝나면 리액트는 포인터를 변경해 `workInProgress` 트리를 현재 트리로 바꿔 버리는데, 이러한 기술을 더블 버퍼링이라고 부르며 이는 커밋 단계에서 진행된다.

![react fiber tree from https://www.velotio.com/engineering-blog/react-fiber-algorithm](https://cdn.prod.website-files.com/5d2dd7e1b4a76d8b803ac1aa/5f604fd80b9cb018d27eeda5_UsoMdBUqB9kLNWjrraBggD3QUb-fuTlKw_u6h_vBx5OnMHZnxTYUQcaoZa_nP9fwCA1nWLEvAnAnlwjMDg2io4z7DPJ5LA8K7qSwTs4_rBJHVuZQrEX-TZOzzOPyhN7FEncG91vy.png)

파이버의 작업 순서는 다음과 같다:

1. `beginWork()` 함수를 실행해 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작.
2. 작업이 끝난다면 `completeWork()` 함수를 실행해 파이버 작업을 완료.
3. 형제가 있다면 형제로 넘어간다.
4. 위 작업이 모두 끝났다면 return으로 돌아가 자신의 작업이 끝났음을 알림.

리액트는 이렇게 **최초 렌더링 시 모든 파이버를 새롭게 생성 ➡ 변경사항 발생 시 기존 파이버에서 새롭게 업데이트된 props를 받아 처리** 라는 방식을 사용해 가급적 새로운 파이버를 생성하지 않는 효율적인 방식으로 가상 DOM을 처리한다.

### 2.4 파이버와 가상 DOM

정리하자면, 파이버는 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있으며, 이러한 파이버는 리액트 아키텍처 내부에서 비동기적으로 이뤄진다. 반면 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 작업을 처리하는 중 불완전하게 표시될 수 있는 가능성이 높기에 메모리상에서 먼저 수행해 최종적인 결과물만 DOM에 남긴다는 것이다.

### 2.5 느낀점 및 정리

> 📝 가상 DOM과 리액트의 핵심은 브라우저의 DOM을 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현, 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이다.

이번 절에서는 DOM과 가상 DOM에 대해서, 그리고 가상 DOM을 관리하는 리액트 파이버와 그것의 작동 방식에 대해서 알게 되었다. 브라우저의 렌더링 과정에 대해서 복습할 수 있었으며, 또 잘못 알고 있었던 '가상 DOM은 무조건 DOM보다 빠르다'는 내용을 타파할 수 있었다.

### 아하 모먼트: 가상 DOM은 무조건 DOM보다 빠를까?

> 🤔 리액트의 VDOM은 무조건 DOM보다 빠른가요? <br/> 🧑🏻‍💻 그렇지 않다. 다만 앱을 개발할 수 있을 만큼 합리적으로 빠르기 때문에 채용했다고 보는 것이 옳다.

이 질문에 대해서 예전에 [관련 영상](https://www.youtube.com/watch?v=kgnv6ZOa81w)을 본 적이 있다. 가상 DOM이 무조건적으로 빠른 것이 아니라는 설명과 함께 diffing과 batching이라는 용어를 알게 되었고, 궁금해져서 공부하게 되었다.

https://old.million.dev/blog/virtual-dom

## 3. 클래스 컴포넌트와 함수 컴포넌트
