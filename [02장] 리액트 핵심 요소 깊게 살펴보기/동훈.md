# 2장: 리액트 핵심 요소 깊게 살펴보기

## 1. JSX란?

> 📝 JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법입니다.

- JSX는 리액트의 전유물이 아닌 내장형 구문이다.
- ECMAScript의 일부는 아니기 때문에, 반드시 트랜스파일러를 거쳐야 한다.

### 1.1 JSX의 정의

> JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성되어 있다.

#### JSX Element

JSX의 기본 요소로, HTML의 요소와 비슷한 역할을 한다. JSX Element가 되기 위해서는 다음과 같은 형태여야 한다.

- `JSXOpeningElement`: 일반적으로 볼 수 있는 요소
- `JSXClosingElement`: Opening Element가 종료되었음을 알리는 요소
- `JSXSelfClosingElement`: 스스로 닫히는 형태
- `JSXFragment`: 아무런 요소가 없는 형태

```jsx
// Opening Element
<JSXElement JSXAttributes(optional)>

// Closing Element
</JSXElement>

// JSXSelfClosingElement
<JSXElement JSXAttributes(optional) />

// JSXFragment
<>JSXChildren(optional)</>
```

> 🤔 JSX 요소명은 왜 대문자로 시작해야 하나요? <br/>🧑🏻‍💻 그 이유는 HTML 요소와 JSX에서 사용자가 만든 컴포넌트 이름을 구분짓기 위해서입니다.

#### JSXElementName

JSXElement의 요소 이름으로 사용할 수 있는 것을 의미한다.

- `JSXIdentifier`: JSX 내부에서 사용할 수 있는 식별자로, JS의 식별자 규칙과 동일하다.
- `JSXNamespacedName`: `:`을 통해 서로 다른 식별자를 이어줄 수 있으나, 두 개 이상을 이을 수는 없다.
- `JSXMemberExpression`: `.`을 통해 서로 다른 식별자를 이어줄 수 있다. `JSXNamespacedName`와는 다르게, 여러 개를 이을 수 있다.

```jsx
function JSXIdentifier() {
  return <$></$>;
}

function JSXNamespacedName() {
  return <foo:bar></foo:bar>;
}

function JSXMemberExpression() {
  return <foo.bar></foo.bar>;
}
```

#### JSXAttributes

`JSXElement`에 부여할 수 있는 속성이다. 단순한 속성이기 때문에 필수가 아니다.

- `JSXSpreadAttributes`: JS의 전개 연산자와 동일한 역할
- `JSXAttribute`: 속성을 나타내는 키-값 쌍으로 이루어져 있다.
  - `JSXAttributeName`: 속성의 키 값으로, JSXIdentifier와 JSXNamespacedName이 가능하다.
  - `JSXAttributeValue`: 속성의 키에 할당할 수 있는 값이다.
    - 큰따옴표/작은따옴표로 구성된 문자열
    - {AssignmentExpression}
    - JSXElement

#### JSXChildren

`JSXElement`의 자식 값을 나타낸다.

- JSXChild: JSXChildren을 이루는 기본 단위로 0개 이상 존재할 수 있다.
  - `JSXText`: `{`,`<`,`>`,`}`을 제외한 문자열이다. 이는 다른 JSX 문법과 혼동을 줄 수 있기 떄문이다.
  - `JSXElement`: 다른 JSX 요소가 값으로 들어갈 수 있다.
  - `JSXFragment`: 빈 요소 역시 들어갈 수 있다.
  - `{JSXChildExpression(optional)}`: JS의 AssignmentExpression을 의미한다.

```jsx
// JSXText
function JSXText() {
  return <>{'{} <>'}</>;
}

// JSXChildExpression
export default function App() {
  return <>{(() => 'foo')()}</>;
}
```

#### JSXStrings

`JSXAttributeValue`와 `JSXText`는 HTML과 JSX 사이에 복사/붙여넣기를 쉽게 할 수 있도록 설계되어 있다. 즉 HTML에서 사용 가능한 문자열은 JSXStrings에서도 가능하다.

> 단, `\`로 시작되는 이스케이프 문자 형태소는 JS와는 다르게 아무런 제약 없이 사용할 수 있다.

### 1.2 JSX 예제

위 내용을 바탕으로 간단한 JSX를 만들어 볼 수 있는 절이었다. 그동안 리액트를 사용하면서 자주 볼 수 있는 형태라 눈에 금방 익었다.

### 1.3 JSX는 어떻게 자바스크립트에서 변환될까?

> 📝 JSX가 JS로 변환될 때에는 `@babel/plugin-transform-react-jsx` 플러그인을 사용한다.

```jsx
const Component = (
  <div required={true}>
    <span>hello world</span>
  </div>
);
```

예를 들어, 위 JSX를 변환한 결과는 다음과 같다.

```js
'use strict';

var Component = React.CreateElement(
  'div',
  { required: true },
  React.CreateElement('span', null, 'hello world')
);

// automatic runtime 트랜스파일 결과
var _jsxRuntime = require('custom-jsx-library/jsx-runtime');

var Component = (0, _jsxRuntime.jsx)('div', {
  required: true,
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'hello world',
  }),
});
```

약간의 차이는 있지만, 공통점은 먼저 **JSXElement를 첫 번째 인수로 선언**해 요소를 정의하고, 나머지 옵셔널은 이후 인수로 넘겨주어 처리한다는 것이다. 이 점을 활용한다면, JSXElement를 렌더링할 때 굳이 요소 전체를 감싸지 않더라도 처리할 수 있다. JSXElement만 다르고, 옵셔널이 동일한 상황에서 유용하게 쓰일 수 있다.

```tsx
// 기존에 두 요소를 따로 작성해야 하는 번거로움이 사라졌다.
import { createElement } from 'react';

function DivOrSpan({
  isDiv,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(isDiv ? 'div' : 'span', { className: 'item' }, children);
}
```

### 1.4 정리 및 느낀점

이번 절에서는 JSX가 무엇인지와 그것의 구조에 대해서 살펴보았다. 그동안 리액트로 개발을 진행하면서 JSX의 구조를 생각해 본 적은 없었는데, 이번 절에서 잘 알게 되었다. 또한 JSX가 자바스크립트에서 변환되는 과정이 인상깊었다. 특히 `createElement`를 사용해 JSX를 작성하는 방법을 알게 되었으니, 추후 이를 프로젝트에 적용시킬 때 중복 코드를 최소화 할 수 있을 것이다.

## 2. 가상 DOM과 리액트 파이버

// 여기까지가 2장 업데이트
